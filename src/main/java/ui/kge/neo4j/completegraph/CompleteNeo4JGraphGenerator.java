package ui.kge.neo4j.completegraph;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.TimeUnit;

import org.apache.commons.io.FileUtils;

import com.google.common.base.Stopwatch;

import csvfiltering.CSVProcessor;
import datavalidation.Validation;
import utilities.StringUtilities;

public class CompleteNeo4JGraphGenerator {

	//test method
	public static void main(String[] args) throws IOException {

		Stopwatch stopwatch = Stopwatch.createStarted();

		//Used for JAR generation
		Scanner input = new Scanner(System.in);

		System.out.println("\nEnter existing source folder for CSV files: "); 
		String csvSource = input.nextLine();

		System.out.println("Enter start datetime (yyyy-MM-dd'T'HH:mm:ss) for the desired time period: "); 
		String startDateTime = input.nextLine();

		System.out.println("\nEnter end datetime (yyyy-MM-dd'T'HH:mm:ss) for the desired time period: "); 
		String endDateTime = input.nextLine();

		System.out.println("\nDo your CSV files contain a header (Y or N)?: "); 
		String header = input.nextLine();

		if (header.equalsIgnoreCase("Y")) {
			try {
				System.out.println("Omitting the header from all CSV files...");
				CSVProcessor.removeFirstLineFromFilesInFolder(csvSource);
			} catch (IOException e) {
				e.printStackTrace();
			}
		}

		System.out.println("\nEnter name of new folder where the generated Neo4J CSV files for nodes and relationships will be stored:");
		String parentFolder = input.nextLine();

		input.close(); 

		//for testing in Eclipse...
		//set the time period for which the Neo4J graph will be created (needs to be within the time period of the dataset)
		//		String startDateTime = "2021-01-01T10:00:00";
		//		String endDateTime = "2022-05-01T10:00:00";
		//
		//		String csvSource = "./files/DATASETS/Sample_3M";
		//		String parentFolder = "Neo4J";
		//
		
		createFolders(parentFolder + "/");
		
		String nodeOutput = parentFolder + "/Nodes";
		String relOutput = parentFolder + "/Relationships/";

		
		//TODO: Should copy the headers to a folder that is generated by the jar
//		String headerOutput = parentFolder + "/Headers/";
//		File parent = new File(headerOutput);
//		File headers = new File ("/resources/headers");
//		
//		//copy the headers folder to the desired folder
//		FileUtils.copyDirectory(headers, parent);

		createNeo4JNodes(startDateTime, endDateTime, csvSource, nodeOutput);
		createNeo4JRelationships(nodeOutput, relOutput);

		stopwatch.stop();

		System.out.println("The generation of CSV files for Neo4J import took: " + stopwatch.elapsed(TimeUnit.MINUTES) + " minutes.");

	}

	public static void createNeo4JNodes(String startDateTime, String endDateTime, String csvSource, String csvOutput) {

		//the lists include the columns extracted from the corresponding csv files
		List<Integer> xDocLoadingUnitColumns = new LinkedList<Integer>(Arrays.asList(0,1,2,3,5,6,7,11,12,18,36,37,40,41,42));
		List<Integer> consignmentColumns = new LinkedList<Integer>(Arrays.asList(0,18,23,32,33,34,35,36,40,41));
		List<Integer> shipmentColumns = new LinkedList<Integer>(Arrays.asList(0,3,18,19));
		List<Integer> shipmentItemsColumns = new LinkedList<Integer>(Arrays.asList(0,1,2,3,4));
		List<Integer> loadingUnitColumns = new LinkedList<Integer>(Arrays.asList(0,1,2,3));
		List<Integer> waveColumns = new LinkedList<Integer>(Arrays.asList(0,1,2,4,8,9,10,12,13,14,15,16,17,18,19,20,21));
		List<Integer> hubColumns = new LinkedList<Integer>(Arrays.asList(1));

		//if there are headers in the csv files they should be removed
		//				System.out.println("Removing headers...");
		//				CSVProcessor.removeFirstLineFromFilesInFolder(csvSource);		

		System.out.println("\nThis process may take several minutes to complete...");	  

		String tmpSplitFiles = "tmpSplitFiles/";
		String tmpSplitFilesFiltered = "tmpSplitFilesFiltered/";
		String tmpSplitFilesByColumn = "tmpSplitFilesByColumn/";
		String tmpCorrectedDates = "tmpCorrectedDates/";

		int chunkSize = 50;

		File tmpSplitFilesFolder = new File(tmpSplitFiles);
		File tmpSplitFilesFilteredFolder = new File (tmpSplitFilesFiltered);
		File tmpSplitFilesColumn = new File (tmpSplitFilesByColumn);
		File tmpCorrectedDatesFolder = new File (tmpCorrectedDates);

		File csvSourceFolder = new File (csvSource);
		File csvOutputFolder = new File (csvOutput);

		if (!csvSourceFolder.exists()) {
			csvSourceFolder.mkdir();
		} if (!tmpSplitFilesFolder.exists()) {
			tmpSplitFilesFolder.mkdir();
		} if (!tmpSplitFilesFilteredFolder.exists()) {
			tmpSplitFilesFilteredFolder.mkdir();
		} if (!tmpSplitFilesColumn.exists()) {
			tmpSplitFilesColumn.mkdir();
		} if (!tmpCorrectedDatesFolder.exists()) {
			tmpCorrectedDatesFolder.mkdir();
		} if (!csvOutputFolder.exists()) {
			csvOutputFolder.mkdir();
		} 

		List<File> list = new ArrayList<>();

		try {
			list = CSVProcessor.createFileList(csvSource);
		} catch (IOException e1) {
			e1.printStackTrace();
		}



		for (File file : list) {
			//FIXME: a better approach for manipulating the shipment items file to concatenate shipment id and loading unit id...
			//ensures that the first column in the shipmentitems.csv is a concatenation of shipment id and loading unit id
			if (file.getName().startsWith("shipmentitems")) {
				try {
					reformatShipmentItems(file.getPath());
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}

			System.out.println("Splitting file " + file.getName() + " (" + file.length() / (1024 * 1024) + " MB) into chunks of max size " + chunkSize + " MB...");
			try {
				CSVProcessor.splitCSV(file.getPath(), tmpSplitFiles, chunkSize);
			} catch (IOException e) {
				e.printStackTrace();
			}
		}

		try {
			System.out.println("Filtering the dataset according to desired period...");
			CSVProcessor.filterOnPeriod(startDateTime, endDateTime, tmpSplitFiles, tmpSplitFilesFiltered);
		} catch (ParseException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}

		//filter on columns
		try {
			CSVProcessor.filterOnColumns(tmpSplitFilesFiltered, tmpSplitFilesByColumn, xDocLoadingUnitColumns, consignmentColumns, 
					shipmentColumns, shipmentItemsColumns, loadingUnitColumns, waveColumns, hubColumns);
		} catch (ParseException e1) {
			e1.printStackTrace();
		} catch (IOException e1) {
			e1.printStackTrace();
		}

		//correct datetime format
		System.out.println("Correcting datetime format...");
		try {
			CSVProcessor.formatDates(tmpSplitFilesByColumn, tmpCorrectedDates);
		} catch (IOException e1) {
			e1.printStackTrace();
		}

		System.out.println("Creating Neo4J nodes...");
		try {
			createNeo4JDataset(tmpCorrectedDates, csvOutput);
		} catch (IOException e1) {
			e1.printStackTrace();
		}

		//remove tmp folders after CSV file generation
		try {
			deleteFolder(tmpSplitFilesFolder.toPath());
		} catch (IOException e) {
			e.printStackTrace();
		}

		try {
			deleteFolder(tmpSplitFilesFilteredFolder.toPath());
		} catch (IOException e) {
			e.printStackTrace();
		}

		try {
			deleteFolder(tmpSplitFilesColumn.toPath());
		} catch (IOException e) {
			e.printStackTrace();
		}

		try {
			deleteFolder(tmpCorrectedDatesFolder.toPath());
		} catch (IOException e) {
			e.printStackTrace();
		}

		//clean/validate the csv files (remove null values etc.) 
		//System.out.println("Validating complete CSV files...");
		String inputConsignmentCSV = csvOutput + "/consignments.csv";
		String inputShipmentsCSV = csvOutput + "/shipments.csv";
		String inputShipmentItemsCSV = csvOutput + "/shipmentitems.csv";
		String inputLoadingUnitsCSV = csvOutput + "/loadingunits.csv";
		String inputXDocLoadingUnitsCSV = csvOutput + "/xdlu.csv";
		String inputWavesCSV = csvOutput + "/waves.csv";
		String inputHubsCSV = csvOutput + "/hubreconstructionlocations.csv";

		String outputConsignmentCSV = csvOutput + "/consignments_validated.csv";
		String outputShipmentsCSV = csvOutput + "/shipments_validated.csv";
		String outputShipmentItemsCSV = csvOutput + "/shipmentitems_validated.csv";
		String outputLoadingUnitsCSV = csvOutput + "/loadingunits_validated.csv";
		String outputXDocLoadingUnitsCSV = csvOutput + "/xdlu_validated.csv";
		String outputWavesCSV = csvOutput + "/waves_validated.csv";
		String outputHubsCSV = csvOutput + "/hubreconstructionlocations_validated.csv";

		Validation.validateConsignments(inputConsignmentCSV, outputConsignmentCSV);
		Validation.validateShipments(inputShipmentsCSV, outputShipmentsCSV);	
		Validation.validateShipmentItems(inputShipmentItemsCSV, outputShipmentItemsCSV);	
		Validation.validateLoadingUnits(inputLoadingUnitsCSV, outputLoadingUnitsCSV);	
		Validation.validateXDocLoadingUnits(inputXDocLoadingUnitsCSV, outputXDocLoadingUnitsCSV);
		Validation.validateWaves(inputWavesCSV, outputWavesCSV);		
		Validation.validateHubs(inputHubsCSV, outputHubsCSV);

		//remove the _validated suffix of the validated files
		renameFiles(csvOutput);

	}

	private static void renameFiles (String folder) {

		File parentFolder = new File(folder);
		File[] files = parentFolder.listFiles();

		boolean fileRenameStatus;

		for (File f : files) {

			if (f.getPath().contains("_validated")) {
				fileRenameStatus = new File(f.getPath()).renameTo(new File(f.getPath().substring(0, f.getPath().lastIndexOf("_")) + ".csv"));
			}
		}

	}

	public static void createNeo4JRelationships(String input, String output) {

		//input
		String consignmentCSV = input + "/consignments.csv";
		String shipmentItemCSV = input + "/shipmentitems.csv";
		String xdluCSV = input + "/xdlu.csv";

		//output
		String CONSIGNMENT_INCLUDED_IN_WAVE = output + "CONSIGNMENT_INCLUDED_IN_WAVE.csv";
		String SHIPMENT_ITEM_IN_SHIPMENT = output + "SHIPMENT_ITEM_IN_SHIPMENT.csv";
		String SHIPMENT_ITEM_INCLUDES_LOADING_UNIT = output + "SHIPMENT_ITEM_INCLUDES_LOADING_UNIT.csv";
		String XDLU_INCLUDED_IN_WAVE = output + "XDLU_INCLUDED_IN_WAVE.csv";
		String XDLU_PROCESSED_BY_HUB = output + "XDLU_PROCESSED_BY_HUB.csv";
		String XDLU_INCLUDES_OUTBOUND_CONSIGNMENT = output + "XDLU_INCLUDES_OUTBOUND_CONSIGNMENT.csv";
		String XDLU_INCLUDES_INBOUND_CONSIGNMENT = output + "XDLU_INCLUDES_INBOUND_CONSIGNMENT.csv";
		String XDLU_LOADING_UNIT = output + "XDLU_LOADING_UNIT.csv";

		System.out.println("Creating Neo4J relationships...");

		generateConsignmentIncludedInWaveRel(consignmentCSV, CONSIGNMENT_INCLUDED_IN_WAVE);
		generateShipmentItemInShipmentRel(shipmentItemCSV, SHIPMENT_ITEM_IN_SHIPMENT);
		generateShipmentItemIncludesLoadingUnitRel(shipmentItemCSV, SHIPMENT_ITEM_INCLUDES_LOADING_UNIT);
		generateXdluIncludedInWaveRel(xdluCSV, XDLU_INCLUDED_IN_WAVE);
		generateXdluProcessedByHubRel(xdluCSV, XDLU_PROCESSED_BY_HUB);
		generateXdluIncludesOutboundConsignmentRel(xdluCSV, XDLU_INCLUDES_OUTBOUND_CONSIGNMENT);
		generateXdluIncludesInboundConsignmentRel(xdluCSV, XDLU_INCLUDES_INBOUND_CONSIGNMENT);
		generateXdluLoadingUnitRel(xdluCSV, XDLU_LOADING_UNIT);

	}




	public static void createNeo4JDataset (String tmpSplitFilesFiltered, String joinedCSVOutputFolder) throws IOException {

		//process each sub-folder (e.g. consignments_split_filtered) in tmpSplitFilesFiltered
		File parentFolder = new File(tmpSplitFilesFiltered);
		File[]folders = parentFolder.listFiles();
		File joinedCSV = null;
		for (File f : folders) {

			if (f.listFiles().length <= 1 && !f.getName().endsWith("_ids")) {
				File[] singleFiles = f.listFiles();
				//if only one file, have the name of the file be filename until '_'
				for (File sf : singleFiles) {
					FileUtils.copyFile(sf, new File(joinedCSVOutputFolder + "/" + sf.getName().substring(0, sf.getName().indexOf("_")) + ".csv"));
				}
			} else if (!f.getName().endsWith("_ids")) {

				joinedCSV = CSVProcessor.joinFiles(f, new File(joinedCSVOutputFolder + "/" + f.getName().substring(0,f.getName().indexOf("_")) + ".csv"));

			}
		}

	}

	public static void generateConsignmentIncludedInWaveRel (String consignmentCSV, String CONSIGNMENT_INCLUDED_IN_WAVE) {

		BufferedReader br = null;
		BufferedWriter bw = null;
		String[] params = null;
		String line;		

		try {
			br = new BufferedReader(new FileReader(consignmentCSV));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		try {
			bw = new BufferedWriter(new FileWriter(CONSIGNMENT_INCLUDED_IN_WAVE));
		} catch (IOException e) {
			e.printStackTrace();
		}

		try {
			while ((line = br.readLine()) != null) {

				params = line.split(",");

				bw.write(params[0] + "," + params[1] + ",CONSIGNMENT_INCLUDED_IN_WAVE");
				bw.newLine();

			}
		} catch (IOException e) {
			e.printStackTrace();
		} 
		try {
			br.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		try {
			bw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	public static void generateShipmentItemInShipmentRel (String shipmentItemCSV, String SHIPMENT_ITEM_IN_SHIPMENT) {

		BufferedReader br = null;
		BufferedWriter bw = null;
		String[] params = null;
		String line;		

		try {
			br = new BufferedReader(new FileReader(shipmentItemCSV));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		try {
			bw = new BufferedWriter(new FileWriter(SHIPMENT_ITEM_IN_SHIPMENT));
		} catch (IOException e) {
			e.printStackTrace();
		}

		try {
			while ((line = br.readLine()) != null) {

				params = line.split(",");

				bw.write(params[0] + "," + params[1] + ",SHIPMENT_ITEM_IN_SHIPMENT");
				bw.newLine();

			}
		} catch (IOException e) {
			e.printStackTrace();
		} 
		try {
			br.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		try {
			bw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	public static void generateShipmentItemIncludesLoadingUnitRel (String shipmentItemCSV, String SHIPMENT_ITEM_INCLUDES_LOADING_UNIT) {

		BufferedReader br = null;
		BufferedWriter bw = null;
		String[] params = null;
		String line;		

		try {
			br = new BufferedReader(new FileReader(shipmentItemCSV));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		try {
			bw = new BufferedWriter(new FileWriter(SHIPMENT_ITEM_INCLUDES_LOADING_UNIT));
		} catch (IOException e) {
			e.printStackTrace();
		}

		try {
			while ((line = br.readLine()) != null) {

				params = line.split(",");

				bw.write(params[0] + "," + params[2] + ",SHIPMENT_ITEM_INCLUDES_LOADING_UNIT");
				bw.newLine();

			}
		} catch (IOException e) {
			e.printStackTrace();
		} 
		try {
			br.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		try {
			bw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	public static void generateXdluIncludedInWaveRel (String xdluCSV, String XDLU_INCLUDED_IN_WAVE) {

		BufferedReader br = null;
		BufferedWriter bw = null;
		String[] params = null;
		String line;		

		try {
			br = new BufferedReader(new FileReader(xdluCSV));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		try {
			bw = new BufferedWriter(new FileWriter(XDLU_INCLUDED_IN_WAVE));
		} catch (IOException e) {
			e.printStackTrace();
		}

		try {
			while ((line = br.readLine()) != null) {

				params = line.split(",");

				bw.write(params[0] + "," + params[10] + ",XDLU_INCLUDED_IN_WAVE");
				bw.newLine();

			}
		} catch (IOException e) {
			e.printStackTrace();
		} 
		try {
			br.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		try {
			bw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	public static void generateXdluProcessedByHubRel (String xdluCSV, String XDLU_PROCESSED_BY_HUB) {

		BufferedReader br = null;
		BufferedWriter bw = null;
		String[] params = null;
		String line;		

		try {
			br = new BufferedReader(new FileReader(xdluCSV));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		try {
			bw = new BufferedWriter(new FileWriter(XDLU_PROCESSED_BY_HUB));
		} catch (IOException e) {
			e.printStackTrace();
		}

		try {
			while ((line = br.readLine()) != null) {

				params = line.split(",");

				bw.write(params[0] + "," + params[9] + ",XDLU_PROCESSED_BY_HUB");
				bw.newLine();

			}
		} catch (IOException e) {
			e.printStackTrace();
		} 
		try {
			br.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		try {
			bw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	public static void generateXdluIncludesOutboundConsignmentRel (String xdluCSV, String XDLU_INCLUDES_OUTBOUND_CONSIGNMENT) {

		BufferedReader br = null;
		BufferedWriter bw = null;
		String[] params = null;
		String line;		

		try {
			br = new BufferedReader(new FileReader(xdluCSV));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		try {
			bw = new BufferedWriter(new FileWriter(XDLU_INCLUDES_OUTBOUND_CONSIGNMENT));
		} catch (IOException e) {
			e.printStackTrace();
		}

		try {
			while ((line = br.readLine()) != null) {

				params = line.split(",");

				bw.write(params[0] + "," + params[8] + ",XDLU_INCLUDES_OUTBOUND_CONSIGNMENT");
				bw.newLine();

			}
		} catch (IOException e) {
			e.printStackTrace();
		} 
		try {
			br.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		try {
			bw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	public static void generateXdluIncludesInboundConsignmentRel (String xdluCSV, String XDLU_INCLUDES_INBOUND_CONSIGNMENT) {

		BufferedReader br = null;
		BufferedWriter bw = null;
		String[] params = null;
		String line;		

		try {
			br = new BufferedReader(new FileReader(xdluCSV));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		try {
			bw = new BufferedWriter(new FileWriter(XDLU_INCLUDES_INBOUND_CONSIGNMENT));
		} catch (IOException e) {
			e.printStackTrace();
		}

		try {
			while ((line = br.readLine()) != null) {

				params = line.split(",");

				bw.write(params[0] + "," + params[7] + ",XDLU_INCLUDES_INBOUND_CONSIGNMENT");
				bw.newLine();

			}
		} catch (IOException e) {
			e.printStackTrace();
		} 
		try {
			br.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		try {
			bw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	public static void generateXdluLoadingUnitRel (String xdluCSV, String XDLU_LOADING_UNIT) {

		BufferedReader br = null;
		BufferedWriter bw = null;
		String[] params = null;
		String line;		

		try {
			br = new BufferedReader(new FileReader(xdluCSV));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		try {
			bw = new BufferedWriter(new FileWriter(XDLU_LOADING_UNIT));
		} catch (IOException e) {
			e.printStackTrace();
		}

		try {
			while ((line = br.readLine()) != null) {

				params = line.split(",");

				bw.write(params[0] + "," + params[6] + ",XDLU_LOADING_UNIT");
				bw.newLine();

			}
		} catch (IOException e) {
			e.printStackTrace();
		} 
		try {
			br.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		try {
			bw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}


	private static void createFolders(String parentFolder) throws IOException {

		System.out.println("Creating folders: ");

		String[] listOfFolders = {"Nodes", "Relationships", "Headers"};

		//create the parent target folder
		File p_folder = new File(parentFolder);

		if (!p_folder.exists()) {
			p_folder.mkdir();
		}

		File t_folder = null;

		for (String s : listOfFolders) {
			t_folder = new File(parentFolder + s);
			if (!t_folder.exists()) {
				t_folder.mkdir();
				System.out.println(t_folder.getPath());
			}
		}

	}

	/**
	 * Delete tmp folders after CSV has been generated.
	 * @param path
	 * @throws IOException
	   2. mai 2022
	 */
	private static void deleteFolder(Path path) throws IOException {
		if (Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS)) {
			try (DirectoryStream<Path> entries = Files.newDirectoryStream(path)) {
				for (Path entry : entries) {
					deleteFolder(entry);
				}
			}
		}
		Files.delete(path);
	}

	private static void reformatShipmentItems (String inputFile) throws IOException {

		BufferedReader br = null;
		BufferedWriter bw = null;

		File input = new File (inputFile);
		File output = new File ("tmp");

		//create a tmp file to hold the content
		FileWriter fw = null;		

		try {
			fw = new FileWriter(output);
		} catch (IOException e2) {
			// TODO Auto-generated catch block
			e2.printStackTrace();
		}

		List<String[]> line = new ArrayList<String[]>();

		br = new BufferedReader(new FileReader(input));

		bw = new BufferedWriter(fw);

		try {
			line = StringUtilities.oneByOne(br);
		} catch (Exception e) {
			e.printStackTrace();
		}

		String shipmentId = null;
		String loadingUnitId = null;

		for (String[] params : line) {
			
			//if the file already contains a concatenation of shipment id and loading unit id as id no need to make any changes...
			if (params[0].contains("_")) {
				break;
			} else {//if it doesn´t, concatenate shipment id and loading unit id and use this as the id

			shipmentId = params[0];
			loadingUnitId = params[1];
			try {
				bw.write(shipmentId + "_" + loadingUnitId + "," + params[0] + "," + params[1] + "," + params[2] + "," + params[3] + "," + params[4]);
				bw.newLine();
			} catch (IOException e) {
				e.printStackTrace();
			}
			
			output.renameTo(input);
			
			}
		}//end for

		

	}

}
